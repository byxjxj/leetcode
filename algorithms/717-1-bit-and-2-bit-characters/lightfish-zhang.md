## [717] 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特`0`来表示。第二种字符可以用两比特(`10`或`11`)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为单个比特字符。给定的字符串总是由0结束。

**示例 1**
输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是单个比特字符。

**示例 2**
输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是单比特字符。


**注意**
1 <= len(bits) <= 1000.
bits[i] 总是0 或 1.


### 解法

现在给了我们一个只包含0和1的数组，问我们能否将其正确的分割，使得最后一个字符是个单个位字符。显而易见，需要从头到尾遍历数组，判断是否 `10` `11` `0` 这三种字符

算法的优化点在于缩短遍历路径，因为两比特字符有`11`与`10`且数组最后一个元素为`0`，如果遇到1，下一个元素是`1`或`0`都不用关心，这是一个两比特字符，可以直接`i+2`跳过；如果遇到`0`，这是一个单比特字符，继续`i+1`吧

分割字符到最后，如果i跳到最后一个比特的位置，结尾就是一个单比特字符`0`


```golang
func isOneBitCharacter(bits []int) bool {
	i := 0
	for i < len(bits)-1 {
		if bits[i] == 0 {
			i++
		} else {
			i += 2
		}
	}
	return i == (len(bits) - 1)
}
```

leetcode运行结果：runtime:8ms, memory:2.8MB

简化写法：

```golang
func isOneBitCharacter(bits []int) bool {
	i := 0
	for i < len(bits)-1 {
		i += bits[i] + 1
	}
	return i == (len(bits) - 1)
}
```
leetcode运行结果：runtime:4ms, memory:2.8MB