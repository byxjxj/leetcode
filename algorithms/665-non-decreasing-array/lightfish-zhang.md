## 非递减数列

### 问题描述

给定一个长度为 `n` 的整数数组，你的任务是判断在最多改变 `1` 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 `i(1 <= i < n)`，满足 `array[i] <= array[i + 1]`。

**示例1:**
```
输入: [4,2,3]
输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
```
**示例2:**
```
输入: [4,2,1]
输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
```
**提示:**
-  `n` 的范围为 `[1, 10,000]`。

### 解法

若数组中不存在下降的点，则其为非递减数列；若数组中存在两对下降的元素，则一定不能通过改变`1`个元素来变成一个非递减数列；若数组中只存在一对下降的元素（i-1 与 i），考虑改变其中一个元素来实现 “只改变1个元素来变成非递减数列”:


```golang
// runtime:40ms, memory:6.3MB
func checkPossibility(nums []int) bool {
    if len(nums) < 2 {
        return true
    }
    count := 0
    for i:=1;i<len(nums);i++{
        // 遍历数组，看是否存在下降的元素
        if nums[i-1] > nums[i] {
            // 若数组中存在两对下降的元素，则一定不能通过改变`1`个元素来变成一个非递减数列
            if count == 1 {
                return false
            }
            // 若数组中只存在一对下降的元素（i-1 与 i），考虑改变其中一个元素来实现 “只改变1个元素来变成非递减数列”
            if i == 1 || // 下降的一对元素在最左位置，可以改变第i-1元素，即第1个元素
                (i+1) == len(nums) || // 下降的一对元素在最右位置，可以改变第i个元素
                nums[i-1] <= nums[i+1]  || // 这对元素的右边相邻的元素比第i-1元素小，可以改变第i个元素
                nums[i-2] < nums[i] { // 这对元素的左边相邻的元素比第i元素小，可以改变第i-1个元素
                count = 1
            }else{
                return false
            }
        }
    }
    return true
}
```

